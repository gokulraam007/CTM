# CTM Loss Calculator for Solar Modules
# Author: Gokul Raam G, Senior Engineer-R&DX, Luminous Power Technologies

import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from io import BytesIO
from fpdf import FPDF

st.set_page_config(page_title="CTM Loss Calculator â€“ Solar Modules", layout="wide")

# Header & Branding
st.image("https://avatars.githubusercontent.com/u/87683305", width=70)
st.title("ðŸŒž CTM (Cell-to-Module) Loss Calculator")
st.markdown("""
**What is CTM?**
Cell-to-Module (CTM) loss quantifies how much electrical efficiency your solar cells lose when assembled into a complete module.  
Want your solar panels performing at their best? Use this tool to understand, compare, and optimize!

**For:** Beginners & Solar Experts  
**Made by:** Gokul Raam G, Senior Engineer-R&DX, Luminous Power Technologies
""")

# Modes: Simple vs. Advanced
mode = st.radio("Choose your user mode:", ["Simple mode (Quick Estimate)", "Advanced mode (Expert/R&D)"])

COEFF = {
    "shadow_factor": 0.90,
    "encap_penalty": {"EVA": 0.4, "POE": 0.25, "Other": 0.45},
    "contact_to_pct": 1.8,
    "finger_scale": 0.12,
    "busbar_factor_per_busbar": 0.85,
    "mismatch_base": 0.20,
    "baseline_irradiance_kwh_per_m2_per_year": 1400
}

def compute_optical_loss(finger_coverage_pct, inactive_area_pct, encap_type, reflection_pct):
    shadow_loss = (finger_coverage_pct / 100.0) * COEFF["shadow_factor"] * 100.0  # in %
    inactive_loss = inactive_area_pct
    encap_loss = COEFF["encap_penalty"].get(encap_type, COEFF["encap_penalty"]["Other"])
    refl_loss = reflection_pct
    return shadow_loss + inactive_loss + encap_loss + refl_loss

def compute_resistive_loss(contact_res_mohm_cm2, finger_area_mm2, total_finger_length_mm,
                           finger_width_mm, busbar_res_ohm_per_m, num_busbars, connector_type,
                           string_length_cells):
    contact_norm = contact_res_mohm_cm2 / 0.5
    contact_loss = COEFF["contact_to_pct"] * contact_norm
    if finger_area_mm2 <= 0:
        finger_loss = 0.0
    else:
        finger_loss = COEFF["finger_scale"] * (total_finger_length_mm / (finger_area_mm2 + 1e-9)) * 100.0
    busbar_path_factor = max(1.0, string_length_cells / 60.0)
    busbar_loss = (busbar_res_ohm_per_m * busbar_path_factor * 100.0)
    busbar_multiplier = COEFF["busbar_factor_per_busbar"] ** max(0, num_busbars - 1)
    busbar_loss *= busbar_multiplier
    connector_map = {"Round Ribbon": 1.05, "Rectangular Ribbon": 0.92, "Wire (MBB)": 0.85, "Other": 1.0}
    connector_factor = connector_map.get(connector_type, 1.0)
    resistive_loss = (contact_loss + finger_loss + busbar_loss) * connector_factor
    resistive_loss *= 0.02
    return max(0.0, resistive_loss)

def compute_mismatch_loss(cell_std_percent, num_cells):
    if cell_std_percent <= 0:
        return 0.0
    return COEFF["mismatch_base"] * cell_std_percent * np.sqrt(num_cells / 60.0)

def compute_total_ctm(cell_eff_percent, optical_loss_pct, resistive_loss_pct, mismatch_loss_pct):
    total_loss = optical_loss_pct + resistive_loss_pct + mismatch_loss_pct
    module_eff = max(0.0, cell_eff_percent - total_loss)
    return module_eff, total_loss

def create_pdf_report(summary, breakdown, file_name="CTM_report.pdf"):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=14)
    pdf.cell(0, 10, "CTM (Cell-to-Module) Loss Report", ln=True, align='C')
    pdf.set_font("Arial", size=12)
    pdf.ln(8)
    pdf.cell(0, 10, "RESULT SUMMARY:", ln=True)
    for key, value in summary.items():
        pdf.cell(0, 8, f"{key.replace('_', ' ').capitalize()}: {value}", ln=True)
    pdf.ln(4)
    pdf.cell(0, 10, "Loss Breakdown:", ln=True)
    for idx, row in breakdown.iterrows():
        pdf.cell(0, 8, f"{row['Loss Type']}: {row['Loss (%)']:.3f} %", ln=True)
    pdf.ln(8)
    pdf.multi_cell(0, 10, "Generated by Gokul Raam G, Senior Engineer-R&DX\nLuminous Power Technologies")
    pdf_out = BytesIO()
    pdf.output(pdf_out)
    pdf_out.seek(0)
    return pdf_out

# UI Block
if mode == "Simple mode (Quick Estimate)":
    st.header("Quick CTM Estimate")
    cell_eff = st.number_input("Cell Efficiency (%)", min_value=10.0, max_value=30.0, value=22.0, step=0.1)
    num_cells = st.selectbox("Cells per Module", options=[60, 72, 120, 144], index=0)
    encap_type = st.selectbox("Encapsulation Material", options=["EVA", "POE", "Other"], index=0)
    finger_coverage_pct = st.slider("Finger Metallization Coverage (%)", 2.0, 8.0, 4.5, step=0.1)
    inactive_area_pct = st.slider("Inactive (Frame/Pads) Area (%)", 0.5, 4.0, 1.5, step=0.1)
    contact_res_mohm_cm2 = st.slider("Contact Resistance (mÎ©Â·cmÂ²)", 0.1, 2.0, 0.5, step=0.01)
    reflection_pct = st.slider("Front-surface Reflection (%)", 0.5, 5.0, 1.0, step=0.1)
    cell_std_percent = st.slider("Process variation (cell-to-cell std dev %)", 0.0, 3.0, 0.6, step=0.01)

    wafer_x = 182.2
    wafer_y = 182.2
    total_finger_area = 15.0
    effective_busbar_res = 0.0035
    num_busbars = 5
    connector_type = "Wire (MBB)"

else:
    st.header("Full CTM Model & Calibration")
    cell_eff = st.number_input("Cell Efficiency (%)", min_value=10.0, max_value=30.0, value=22.5, step=0.01)
    num_cells = st.selectbox("Cells per Module", options=[60, 66, 72, 96, 120, 144], index=2)
    wafer_x = st.selectbox("Wafer dimension X (mm)", options=[182.2, 183.75, 210.0], index=0)
    wafer_y = st.selectbox("Wafer dimension Y (mm)", options=[182.2, 210.0], index=0)
    total_busbar_area = st.number_input("Total busbar area (mmÂ² per cell)", value=40.0, step=0.1)
    total_finger_area = st.number_input("Total finger area (mmÂ² per cell)", value=15.0, step=0.1)
    num_busbars = st.selectbox("Number of Busbars (per cell)", options=[1,2,3,4,5,6], index=3)
    connector_type = st.selectbox("Interconnection Type", options=["Round Ribbon", "Rectangular Ribbon", "Wire (MBB)", "Other"])
    effective_busbar_res = st.number_input("Effective busbar resistance (Î©/m)", value=0.0035, step=0.0001)
    finger_coverage_pct = st.slider("Finger coverage (%)", 0.0, 10.0, 4.5, step=0.1)
    inactive_area_pct = st.slider("Inactive area (%) (frame, pads)", 0.0, 10.0, 1.2, step=0.1)
    contact_res_mohm_cm2 = st.slider("Solder / contact resistance (mÎ©Â·cmÂ²)", min_value=0.05, max_value=5.0, value=0.5, step=0.01)
    reflection_pct = st.slider("Front-surface reflection (%)", 0.0, 5.0, 1.0, step=0.1)
    cell_std_percent = st.slider("Cell-to-cell current std dev (%)", 0.0, 5.0, 0.6, step=0.01)

cell_width_mm = wafer_x
estimated_finger_count = max(10, int((cell_width_mm / 0.25)))
total_finger_length_mm = estimated_finger_count * (wafer_y / 2.0)
finger_area_mm2 = total_finger_area

optical_loss = compute_optical_loss(finger_coverage_pct, inactive_area_pct, encap_type, reflection_pct)
resistive_loss = compute_resistive_loss(contact_res_mohm_cm2, finger_area_mm2, total_finger_length_mm,
                                       finger_width_mm=(total_finger_area / (estimated_finger_count + 1.0)),
                                       busbar_res_ohm_per_m=effective_busbar_res,
                                       num_busbars=num_busbars,
                                       connector_type=connector_type,
                                       string_length_cells=num_cells)
mismatch_loss = compute_mismatch_loss(cell_std_percent, num_cells)
module_eff, total_ctm_loss = compute_total_ctm(cell_eff, optical_loss, resistive_loss, mismatch_loss)

area_m2 = ((wafer_x/1000.0) * (wafer_y/1000.0)) * num_cells
baseline_irr_kwh = COEFF["baseline_irradiance_kwh_per_m2_per_year"]
module_power_kw_per_m2 = (module_eff / 100.0) * 1000.0
annual_yield_kwh = (module_power_kw_per_m2 * area_m2) * (baseline_irr_kwh / 1000.0)
annual_power_loss_kwh = (cell_eff / 100.0) * 1000.0 * area_m2 * (baseline_irr_kwh / 1000.0) - annual_yield_kwh

st.markdown("---")
st.header("Results")

colA, colB, colC = st.columns(3)
colA.metric("Cell Efficiency (%)", f"{cell_eff:.2f}")
colB.metric("Module Efficiency (%)", f"{module_eff:.2f}")
colC.metric("Total CTM Loss (%)", f"{total_ctm_loss:.2f}")

st.subheader("Annual Power Loss Due to CTM")
st.warning(f"Estimated annual energy lost due to CTM: {annual_power_loss_kwh:.1f} kWh/year")

df_breakdown = pd.DataFrame({
    "Loss Type": ["Optical (shadow/encap/refl)", "Resistive (wiring)", "Mismatch (cell variation)"],
    "Loss (%)": [optical_loss, resistive_loss, mismatch_loss]
})
st.subheader("CTM Loss Breakdown")
st.table(df_breakdown.style.format({"Loss (%)":"{:.3f}"}))

fig1, ax1 = plt.subplots()
ax1.pie([optical_loss, resistive_loss, mismatch_loss], labels=["Optical", "Resistive", "Mismatch"], autopct='%1.1f%%')
ax1.axis('equal')
st.pyplot(fig1)

st.subheader("Estimated Energy Yield")
st.info(f"Approximate Module Area: {area_m2:.3f} mÂ²\nRough Annual Output: {annual_yield_kwh:.1f} kWh/year")

summary = {
    "cell_eff_%": f"{cell_eff:.2f}",
    "module_eff_%": f"{module_eff:.2f}",
    "total_ctm_loss_%": f"{total_ctm_loss:.2f}",
    "annual_power_loss_kwh": f"{annual_power_loss_kwh:.1f}",
    "annual_output_kwh": f"{annual_yield_kwh:.1f}",
    "module_area_m2": f"{area_m2:.3f}"
}

pdf_bytes = create_pdf_report(summary, df_breakdown)
st.download_button(
    label="Download full CTM report (PDF)",
    data=pdf_bytes,
    file_name="ctm_report.pdf",
    mime="application/pdf"
)

with st.expander("What is CTM Loss? Why does it matter?"):
    st.info("""Cell-to-Module (CTM) loss is the difference between the ideal efficiency of solar cells and the real-world power output of installed solar modules. Lower CTM means more energy in practice! This calculator helps you estimate and minimize those losses for greater savings and sustainability.""")

st.markdown("---")
st.caption("Made by Gokul Raam G, Senior Engineer-R&DX | Luminous Power Technologies")
